package edu.ucsf.rbvi.contactApp.internal.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSlider;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JWindow;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;

import org.cytoscape.application.CyApplicationManager;
import org.cytoscape.application.swing.CySwingApplication;
import org.cytoscape.application.swing.CytoPanel;
import org.cytoscape.application.swing.CytoPanelComponent;
import org.cytoscape.application.swing.CytoPanelName;
import org.cytoscape.application.swing.CytoPanelState;
import org.cytoscape.model.CyEdge;
import org.cytoscape.model.CyNetwork;
import org.cytoscape.model.CyNode;
import org.cytoscape.model.CyTableUtil;
import org.cytoscape.model.SavePolicy;
import org.cytoscape.model.subnetwork.CyRootNetwork;
import org.cytoscape.model.subnetwork.CyRootNetworkManager;
import org.cytoscape.view.model.CyNetworkView;
import org.cytoscape.view.model.CyNetworkViewFactory;
import org.cytoscape.view.model.View;
import org.cytoscape.view.presentation.RenderingEngine;
import org.cytoscape.view.model.VisualLexicon;
import org.cytoscape.view.model.VisualProperty;
import org.cytoscape.view.presentation.RenderingEngineFactory;
import org.cytoscape.view.presentation.property.BasicVisualLexicon;
import static org.cytoscape.view.presentation.property.BasicVisualLexicon.*;
import static org.cytoscape.view.presentation.property.ArrowShapeVisualProperty.NONE;
import org.cytoscape.view.presentation.property.NodeShapeVisualProperty;
import org.cytoscape.view.presentation.property.values.NodeShape;
import org.cytoscape.view.vizmap.VisualMappingFunctionFactory;
import org.cytoscape.view.vizmap.VisualMappingManager;
import org.cytoscape.view.vizmap.VisualPropertyDependency;
import org.cytoscape.view.vizmap.VisualStyle;
import org.cytoscape.view.vizmap.VisualStyleFactory;
import org.cytoscape.work.TaskMonitor;

import edu.ucsf.rbvi.contactApp.internal.model.ContactManager;
import edu.ucsf.rbvi.contactApp.internal.model.ContactNetwork;

public class ContactPanel extends JPanel implements CytoPanelComponent {
  private static final long serialVersionUID = 1L;
	private final ContactManager contactManager;
	private final CyNetwork network;
	private final CyNetworkView networkView;
	private ContactNetworkBrowser contactNetworkBrowser;

	// table size parameters
	private static final int graphPicSize = 80;
	private static final int defaultRowHeight = graphPicSize + 8;

	// Services we'll need
	private final VisualStyleFactory visualStyleFactory;
	private final CyNetworkViewFactory networkViewFactory;
	private final VisualMappingManager visualMappingMgr;
	private final RenderingEngineFactory<CyNetwork> renderingEngineFactory;

	private VisualStyle componentStyle = null;

	private boolean interrupted;

	public ContactPanel(ContactManager cManager, CyNetwork net) {
		contactManager = cManager;
		if (net == null) {
			this.network = contactManager.getCurrentNetwork();
			this.networkView = contactManager.getCurrentNetworkView();
		} else {
			this.network = net;
			// TODO: get the list of views from the view manager
			this.networkView = contactManager.getCurrentNetworkView();
		}

		visualStyleFactory = contactManager.getService(VisualStyleFactory.class);
		networkViewFactory = contactManager.getService(CyNetworkViewFactory.class);
		visualMappingMgr = contactManager.getService(VisualMappingManager.class);
		renderingEngineFactory = contactManager.getService(RenderingEngineFactory.class);

		setLayout(new BorderLayout());
		contactNetworkBrowser = new ContactNetworkBrowser(this, contactManager);
		add(contactNetworkBrowser, BorderLayout.CENTER);
		this.setSize(this.getMinimumSize());
	}

	public Component getComponent() {
		return this;
	}

	@Override
	public CytoPanelName getCytoPanelName() {
		return CytoPanelName.EAST;
	}

	@Override
	public Icon getIcon() {
		return null;
	}

	@Override
	public String getTitle() {
		return "Contact Networks";
	}

	private class ContactNetworkBrowser extends JPanel implements ListSelectionListener, ChangeListener {
		private ContactBrowserTableModel tableModel;
		private final JTable table;
		private final JScrollPane tableScrollPane;
		private JLabel tableLabel;
		private final JSlider slider;
		private final ContactPanel contactPanel;
		private final ContactManager contactManager;
		private double tStress = 0.25;
		private List<Double> stresses = null;
		protected final DecimalFormat formatter;
		int minStress = 0;
		int maxStress = 0;

		public ContactNetworkBrowser(ContactPanel component, ContactManager contactManager) {
			super();

			contactPanel = component;
			this.contactManager = contactManager;
			formatter = new DecimalFormat("0.00");

			setLayout(new BorderLayout());

			stresses = new ArrayList<Double>(contactManager.getStressSet());
			Collections.sort(stresses);
			minStress = (int)(stresses.get(0)*100.0);
			maxStress = (int)(stresses.get(stresses.size()-1)*100.0);

			JPanel sliderPanel = new JPanel(new BorderLayout());
			JLabel sliderLabel = new JLabel("<html><b>&nbsp;&nbsp;T<sub>stress</sub></b>&nbsp;&nbsp;</html>");
			sliderPanel.add(sliderLabel, BorderLayout.WEST);

			slider = new JSlider(minStress, maxStress, (int)(tStress*100.0));
			slider.setLabelTable(generateLabels(stresses));
			slider.setPaintLabels(true);
			slider.addChangeListener(this);
			sliderPanel.add(slider, BorderLayout.CENTER);
			
			// Put a border around our sliderPanel
			Border outer = BorderFactory.createEtchedBorder();
			Border inner = BorderFactory.createEmptyBorder(10,10,10,10);
			Border compound = BorderFactory.createCompoundBorder(outer, inner);
			sliderPanel.setBorder(compound);
			add(sliderPanel, BorderLayout.NORTH);

			// Create a new JPanel for the table
			JPanel tablePanel = new JPanel(new BorderLayout());
			String stressLabel = formatter.format(tStress);
			tableLabel = new JLabel("<html><h3>&nbsp;&nbsp;Connected Components for T<sub>stress</sub>="+
											        stressLabel+"</h3></html>");
			tablePanel.add(tableLabel, BorderLayout.NORTH);

			tableModel = new ContactPanel.ContactBrowserTableModel(contactManager, tStress);
			table = new JTable(tableModel);

			table.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
			table.setAutoCreateRowSorter(true);
			table.setIntercellSpacing(new Dimension(0, 4)); // gives a little vertical room between clusters
			table.setFocusable(false); // removes an outline that appears when the user clicks on the images
			table.setRowHeight(defaultRowHeight);

			// Ask to be notified of selection changes.
			ListSelectionModel rowSM = table.getSelectionModel();
			rowSM.addListSelectionListener(this);

			tableScrollPane = new JScrollPane(table);
			//System.out.println("CBP: after creating JScrollPane");
			tableScrollPane.getViewport().setBackground(Color.WHITE);
			tablePanel.add(tableScrollPane, BorderLayout.CENTER);
			add(tablePanel);
		}

		public void valueChanged(ListSelectionEvent e) {
			int[] rows = table.getSelectedRows(); // Get all of the selected rows

			// Clear the current selection
			for (CyNode node: network.getNodeList())
				network.getRow(node).set(CyNetwork.SELECTED, false);

			for (int viewRow: rows) {
				int modelRow = table.convertRowIndexToModel(viewRow);
				tableModel.selectFromRow(modelRow);
			}
			networkView.updateView();
		}

		public void stateChanged(ChangeEvent e) {
			if (e.getSource() != slider) return;
			int stress = slider.getValue();
			double dStress = ((double)stress)/100.0;
			for (int i = 0; i < stresses.size(); i++) {
				double v = stresses.get(i);
				if (dStress > v) continue;
				if (dStress == v) break;
				double vLow = stresses.get(i-1);
				if ((dStress - vLow) < (v - dStress)) {
					dStress = vLow;
					break;
				} else {
					dStress = v;
					break;
				}
			}
			tStress = dStress;

			String stressLabel = formatter.format(tStress);
			tableLabel.setText("<html><h3>&nbsp;&nbsp;Connected Components for T<sub>stress</sub> = "+
			                   stressLabel+"</h3></html>");

			// Create the new tableModel
			tableModel.updateData(tStress);

			// FIXME: For some reason, the table doesn't update!
			// table.revalidate();
			// tableScrollPane.revalidate();
			// tableScrollPane.repaint();
		}

		public Dictionary<Integer, JComponent> generateLabels(List<Double> stresses) {
			Dictionary<Integer, JComponent> table = new Hashtable<>();
			for (Double stress: stresses) {
				int value = (int)(stress.doubleValue()*100.0+0.5);
				if (value%5 != 0) continue;
				String label = formatter.format(stress);
				JLabel jLabel = new JLabel(label); // May have to use a text formatter
				jLabel.setFont(new Font("SansSerif", Font.BOLD, 8));
				table.put(value, jLabel);
			}
			return table;
		}
	}

	private class ContactBrowserTableModel extends AbstractTableModel {
		private final ContactManager contactManager;
		private Object[][] data;
		private List<CyNetwork> componentNetworks;
		private List<Color> componentColors;
		private final String[] columnNames = { "Subnetwork", "Color" };
		private Map<Integer, CyNode> residueMap;

		public ContactBrowserTableModel(ContactManager contactManager, double tStress) {
			this.contactManager = contactManager;
			residueMap = new HashMap<>();

			// Build our residue index to node map
			if (network.getDefaultNodeTable().getColumn("Resindex") != null) {
				for (CyNode node: network.getNodeList()) {
					Integer index = network.getRow(node).get("Resindex", Integer.class);
					residueMap.put(index, node);
					View<CyNode> nv = networkView.getNodeView(node);
					nv.clearValueLock(NODE_FILL_COLOR);
				}
			}
			updateData(tStress);
		}

		public void updateData(double tStress) {
			ContactNetwork contactNetwork = contactManager.getContactNetwork(tStress);
			componentNetworks = contactNetwork.getNetworkComponents();
			Collections.sort(componentNetworks, new NetworkSorter());
			componentColors = generateColors(componentNetworks.size());

			this.data = new Object[componentNetworks.size()][columnNames.length];

			for (int i = 0; i < componentNetworks.size(); i++) {
				CyNetwork componentNetwork = componentNetworks.get(i);
				Color color = componentColors.get(i);
				SpringEmbeddedLayouter layouter = new SpringEmbeddedLayouter();
				final Image image = createNetworkImage(componentNetwork, color,
				                                       graphPicSize, graphPicSize, layouter, false);
				NetworkImageIcon icon = image != null ? 
				                            new NetworkImageIcon(image, componentNetwork) : 
														        new NetworkImageIcon();
				setValueAt(icon, i, 0);
				setValueAt(color, i, 1);

				for (CyNode cNode: componentNetwork.getNodeList()) {
					Integer resId = new Integer(componentNetwork.getRow(cNode).get("ResidueNumber", Integer.class));
					if (residueMap.containsKey(resId)) {
						CyNode targetNode = residueMap.get(resId);
						View<CyNode> nv = networkView.getNodeView(targetNode);
						// nv.setLockedValue(NODE_PAINT, color);
						nv.setVisualProperty(NODE_FILL_COLOR, color);
					}
				}
			}
			networkView.updateView();
		}

		@Override
		public String getColumnName(int col) {
			return columnNames[col];
		}

		@Override
		public int getColumnCount() {
			return columnNames.length;
		}

		@Override
		public int getRowCount() {
			return data.length;
		}

		@Override
		public Object getValueAt(int row, int col) {
			return data[row][col];
		}

		@Override
		public void setValueAt(Object object, int row, int col) {
			data[row][col] = object;
			fireTableCellUpdated(row, col);
		}

		@Override
		public Class<?> getColumnClass(int c) {
			return getValueAt(0, c).getClass();
		}

		public void selectFromRow(int modelRow) {
			NetworkImageIcon netImage = (NetworkImageIcon)getValueAt(modelRow, 0);
	
			CyNetwork net = netImage.getNetwork();
			for (CyNode cNode: net.getNodeList()) {
				Integer resId = new Integer(net.getRow(cNode).get("ResidueNumber", Integer.class));
				if (residueMap.containsKey(resId)) {
					CyNode targetNode = residueMap.get(resId);
					network.getRow(targetNode).set(CyNetwork.SELECTED, true);
				}
			}
		}

		private List<Color> generateColors(int number) {
			int[][] colorArray = new int[][] {
							{0,0,153,255}, // Dark Blue
							{153,0,0,255}, // Dark Red
							{0,153,0,255}, // Dark Green
							{255,153,0,255}, // Orange
							{0,255,0,255}, // Green
							{0,255,255,255}, // Cyan
							{255,0,255,255}, // Magenta
							{0,153,153,255}, // Dark Cyan
							{153,0,153,255}, // Dark Magenta
							{0,153,255,255}, // Light blue
							{255,102,153,255}, // Light red
							{0,255,153,255}, // Light green

				};
			List<Color> colors = new ArrayList<>();
			for (int i = 0; i < number; i++) {
				if (i < colorArray.length)
					colors.add(new Color(colorArray[i][0], colorArray[i][1], 
					                     colorArray[i][2], colorArray[i][3]));
				else
					colors.add(new Color(192,192,192,128));
			}
			return colors;
		}

	}

	public Image createNetworkImage(final CyNetwork net,
									final Color nodeColor,
									final int height,
									final int width,
									SpringEmbeddedLayouter layouter,
									boolean layoutNecessary) {
		//System.out.println("CCI: inside method");
		
		//System.out.println("CCI: after getting root and network ");
		// Progress reporters.
		// There are three basic tasks, the progress of each is calculated and then combined
		// using the respective weighting to get an overall progress global progress
		int weightSetupNodes = 20; // setting up the nodes and edges is deemed as 25% of the whole task
		int weightSetupEdges = 5;
		double weightLayout = 75.0; // layout it is 70%
		double goalTotal = weightSetupNodes + weightSetupEdges;

		if (layoutNecessary) {
			goalTotal += weightLayout;
		}

		// keeps track of progress as a percent of the totalGoal
		double progress = 0;

		final VisualStyle vs = getComponentStyle();

		//System.out.println("CCI: after getComponentStyle");
		final CyNetworkView componentView = createNetworkView(net, vs);
		//System.out.println("CCI: after createNetworkView");

		componentView.setVisualProperty(NETWORK_WIDTH, new Double(width));
		componentView.setVisualProperty(NETWORK_HEIGHT, new Double(height));

		for (View<CyNode> nv : componentView.getNodeViews()) {
			if (interrupted) {
				//logger.debug("Interrupted: Node Setup");
				// before we short-circuit the method we reset the interruption so that the method can run without
				// problems the next time around
				if (layouter != null) layouter.resetDoLayout();
				resetLoading();

				return null;
			}

			// Node position
			final double x;
			final double y;

			// Otherwise, randomize node positions before layout so that they don't all layout in a line
			// (so they don't fall into a local minimum for the SpringEmbedder)
			// If the SpringEmbedder implementation changes, this code may need to be removed
			// size is small for many default drawn graphs, thus +100
			x = (componentView.getVisualProperty(NETWORK_WIDTH) + 100) * Math.random();
			y = (componentView.getVisualProperty(NETWORK_HEIGHT) + 100) * Math.random();

			if (!layoutNecessary) {
				goalTotal += weightLayout;
				progress /= (goalTotal / (goalTotal - weightLayout));
				layoutNecessary = true;
			}

			nv.setVisualProperty(NODE_X_LOCATION, x);
			nv.setVisualProperty(NODE_Y_LOCATION, y);
			nv.setLockedValue(NODE_PAINT, nodeColor);
			nv.setLockedValue(NODE_FILL_COLOR, nodeColor);
		}

		if (componentView.getEdgeViews() != null) {
			for (int i = 0; i < componentView.getEdgeViews().size(); i++) {
				if (interrupted) {
					//logger.error("Interrupted: Edge Setup");
					if (layouter != null) layouter.resetDoLayout();
					resetLoading();

					return null;
				}
				/*
				if (loader != null) {
					progress += 100.0 * (1.0 / (double) componentView.getEdgeViews().size()) *
								((double) weightSetupEdges / (double) goalTotal);
					loader.setProgress((int) progress, "Setup: edges");
				}
				*/
			}
		}

		if (layoutNecessary) {
			if (layouter == null) {
				layouter = new SpringEmbeddedLayouter();
			}

			layouter.setGraphView(componentView);

			// The doLayout method should return true if the process completes without interruption
			if (!layouter.doLayout(weightLayout, goalTotal, progress)) {
				// Otherwise, if layout is not completed, set the interruption to false, and return null, not an image
				resetLoading();

				return null;
			}
		}

		final Image image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
		final Graphics2D g = (Graphics2D) image.getGraphics();

		SwingUtilities.invokeLater(new Runnable() {
			//@Override
			public void run() {
				try {
					final Dimension size = new Dimension(width, height);

					JPanel panel = new JPanel();
					panel.setPreferredSize(size);
					panel.setSize(size);
					panel.setMinimumSize(size);
					panel.setMaximumSize(size);
					panel.setBackground((Color) vs.getDefaultValue(NETWORK_BACKGROUND_PAINT));

					JWindow window = new JWindow();
					window.getContentPane().add(panel, BorderLayout.CENTER);

					RenderingEngine<CyNetwork> re = renderingEngineFactory.createRenderingEngine(panel, componentView);

					vs.apply(componentView);
					componentView.fitContent();
					componentView.updateView();
					window.pack();
					window.repaint();

					re.createImage(width, height);
					re.printCanvas(g);
					g.dispose();

				} catch (Exception ex) {
					throw new RuntimeException(ex);
				}
			}
		});

		layouter.resetDoLayout();
		resetLoading();

		return image;
	}

	private class NetworkImageIcon extends ImageIcon implements Comparable<NetworkImageIcon> {
		protected CyNetwork network;
		static final long serialVersionUID = 1L;

		public NetworkImageIcon() {
			super();
			network = null;
		}

		public NetworkImageIcon(Image image, CyNetwork net) {
			super(image);
			this.network = net;
		}

		public int compareTo(NetworkImageIcon cii2) {
			if ((network == null && cii2.network == null) ||
			    (network.getNodeCount() == cii2.network.getNodeCount()))
				return 0;
			else if (network == null || network.getNodeCount() < cii2.network.getNodeCount())
				return -1;
			return 1;
		}

		public CyNetwork getNetwork() {
			return network;
		}
	}

	private class NetworkSorter implements Comparator<CyNetwork> {
		public NetworkSorter() { }

		public int compare(CyNetwork n1, CyNetwork n2) {
			if (n1 == null && n2 == null) return 0;
			if (n1 == null && n2 != null) return -1;
			if (n2 == null && n1 != null) return 1;

			if(n1.getNodeCount() < n2.getNodeCount()) return 1;
			if(n1.getNodeCount() > n2.getNodeCount()) return -1;
			return 0;
		}
	}


	@SuppressWarnings({ "unchecked", "rawtypes" })
	public VisualStyle getComponentStyle() {
		if (componentStyle == null) {
			componentStyle = visualStyleFactory.createVisualStyle("Cluster");

			componentStyle.setDefaultValue(NODE_SIZE, 40.0);
			componentStyle.setDefaultValue(NODE_WIDTH, 40.0);
			componentStyle.setDefaultValue(NODE_HEIGHT, 40.0);
			componentStyle.setDefaultValue(NODE_PAINT, Color.RED);
			componentStyle.setDefaultValue(NODE_FILL_COLOR, Color.RED);
			componentStyle.setDefaultValue(NODE_BORDER_WIDTH, 0.0);

			componentStyle.setDefaultValue(EDGE_WIDTH, 5.0);
			componentStyle.setDefaultValue(EDGE_PAINT, Color.BLUE);
			componentStyle.setDefaultValue(EDGE_UNSELECTED_PAINT, Color.BLUE);
			componentStyle.setDefaultValue(EDGE_STROKE_UNSELECTED_PAINT, Color.BLUE);
			componentStyle.setDefaultValue(EDGE_SELECTED_PAINT, Color.BLUE);
			componentStyle.setDefaultValue(EDGE_STROKE_SELECTED_PAINT, Color.BLUE);
			componentStyle.setDefaultValue(EDGE_TARGET_ARROW_SHAPE, NONE);
			componentStyle.setDefaultValue(EDGE_SOURCE_ARROW_SHAPE, NONE);

			/*
			//System.out.println("GCS: before getVisual Lexicon");
			VisualLexicon lexicon = applicationMgr.getCurrentRenderingEngine().getVisualLexicon();
			VisualProperty vp = lexicon.lookup(CyEdge.class, "edgeTargetArrowShape");
			//System.out.println("CCI: after setting visual property");

			if (vp != null) {
				Object arrowValue = vp.parseSerializableString("ARROW");
				System.out.println("Edge target arrow value = "+arrowValue.toString());
				if (arrowValue != null) componentStyle.setDefaultValue(vp, arrowValue);
			}
			*/
		}

		return componentStyle;
	}

	public CyNetworkView createNetworkView(final CyNetwork net, VisualStyle vs) {
		final CyNetworkView view = networkViewFactory.createNetworkView(net);
		//System.out.println("inside createNetworkView");
		if (vs == null) vs = visualMappingMgr.getDefaultVisualStyle();
		visualMappingMgr.setVisualStyle(vs, view);
		vs.apply(view);
		view.updateView();

		return view;
	}

	public void interruptLoading() {
		interrupted = true;
	}

	public void resetLoading() {
		interrupted = false;
	}

}
